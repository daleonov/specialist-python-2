## 1.1 Точка на плоскости

Написать класс PointXY, у которого есть атрибуты x и y.

Сделать методы
а) расстояние от начала координат до этой точки

``` python
d0 = p0.distance_from_zero()
```

б) расстояние от точки до другой точки

``` python
d = p0.distance_to(p4)
```

в) Дополнить класс PointXY, чтобы можно было указывать координаты при создании


``` python
class PointXY:
    def __init__(self, ...):
        # ...

# ...

p1 = PointXY(3, 4)
```

## 1.2 Автомобиль

Сделать класс Car
c1 = Car()

а) У машины должны быть атрибуты
* "сколько бензина в баке"
* "вместимость бака" - сколько максимум влезаем бензина
* "расход топлива на км"

``` python
c1.gas_l = 30
c1.capacity_l = 40
c1.l_per_km = 0.1
```

б) метод "залить столько-то литров в бак"

``` python
c1.fill(5) # залили 5 литров
```

должна учитываться вместительность бака
если пытаемся залить больше, чем вмещается, то заполняется полностью + print'ом выводится сообщение о лишних литрах

в) метод "проехать сколько-то км"

``` python
c1.ride(50)
```

выведет принт "проехали ... километров"
в результате поездки потратится бензин
если бензина не хватает, машина всё равно едет, пока не кончится бензин

г) добавить атрибут с пробегом, который увеличивается в результате ride

★д) сделать так, чтобы расход топлива увеличивался на 5% каждые 1000км



## 1.3 Прямоугольник по двум сторонам
Создать класс прямоугольник:

а) при создании указывается ширина и длина

``` python
r1 = Rect(10, 56)
```

б) методы для площади и периметра

``` python
print(r1.area())  # возвращает площадь
print(r1.perimeter())  # периметр
```

в) масштабирование и поворот

``` python
r1.scale(10) - высота и ширина увеличиваются в 10 раз
r1.scale(0.1) - высота и ширина уменьшаются в 10 раз
r1.rotate() - меняется ширина и высота местами
```

## 1.4 Прямоугольник по двум точкам
На основе предыдущих двух задач (PointXY и Rect) сделать прямоугольник, у которого задаются координаты вершин. Стороны при этом всегда параллельны осям координат, то есть для задания достаточно двух точек (вершин).

а) при создании указываются две любые вершины типа PointXY
p1 = PointXY(1,2)
p2 = PointXY(5,6)
r2 = Rect(p1, p2)
print(r2.area())

(Методы rotate и scale можно не делать)

б) то же самое, но внутри хранить именно нижний левый и верхний правый углы

в) сделать метод, которым можно проверить, лежит ли точка внутри прямоугольника

``` python
print(r1.has_inside(p3)) 
```

г) аналогично пункту в) сделать зеркальный метод у класса PointXY: теперь спрашиваем у точки, лежит ли она внутри указанного прямоугольника

``` python
p1.is_inside(r1)  # находится ли p1 внутри r1
```

## 1.5 Игральные кубики

1. Написать класс Dice - игральный кубик (6 граней, от 1 до 6)
а) ```d1 = Dice()``` - конструктор по умолчанию
б) Сделать метод throw()  -вернёт число от 1 до 6 (можно использовать randrange(1, 7) из модуля random)

``` python
d1 = Dice()
d2 = Dice()
for i in range(10):
	score = d1.throw() + d2.throw()
	print(score)
```

б) Сделать метод ```show_stats()```, который показывает статистику по каждому кубиков (сколько раз какая грань выпала за историю его существования). Каким образом хранить, обновлять и отображать данные, выберите самостоятельно.

в) то же, что и в пункте б), но с общей статистикой по всем кубикам.

г) сделать так, чтобы можно было создавать не только стандартный 6-гранный кубик, но и любой другой; статистику можно хранить как в пункте б)

![Кубики](img/dice.jpg)

``` python
d1 = Dice()  # обычный кубик
d2 = Dice({1, 2, 3, 4})
d3 = Dice(range(0, 91, 10))
```


# 2. Наследование

## 2.1 Телевизор
Сделать класс Display, унаследованный от Rect из задачи 1.2 ("Прямоугольник по двум сторонам")
а) В конструкторе указывается диагоняль в дюймах, ширина и высота в пикселях
``` python
samsung_mon = Display(19, 1920, 1080)  # 19", 1920x1080 пикселей
```

б) Должны вычисляться площадь и периметр (в дюймах или метрах - как хотите). А ещё монитор может поворачиваться на 90 градусов. Методы должны достаться от прямоугольника.

``` python
samsung_mon.area() # площадь в кв. дюймах, либо в кв. м
samsung_mon.perimeter()
samsung_mon.rotate()
```

в) Монитор должен сообщать количество точек на дюйм и количество пикселей на экране

``` python
samsung_mon.get_dpi()  # количество точек на дюйм
samsung_mon.get_pixel_num()  # сколько мегапикселей у экрана
print(samsung_mon.get_resolution_px())  # разрешение в пикселях в виде кортежа: (1920, 1080)
```

---

Дополнительно (по желанию):

1. Дополнить класс "прямоугольник" двумя методами:
r1, r2 - объекты Rect
а) r1.is_larger_than(r2) - фактически "r1 > r2" True, если площадь r1 больше площади r2
б) r1.is_equal(r2) - равны ли пр-ки - если равны их стороны
True/False

2. Дополнить класс PointXY методами:
а) __eq__, __ne__ - сравнение == != - на основе совпадения координат
б) __invert__(self), __neg__(self)
p5 = ~p1
p6 = -p2
координаты уножатся на -1 и там, и там
вернуть нужно новую PointXY
в) __abs__(self) -> float - модуль - длина отрезка между началом координат и этой точкой
г) __add__(self, other) -> PointXY
p3 = p1 + p2 - сумма иксов и игреков
д) __mul__(self, other) -> PointXY - умножить точку на число - просто умножаются координаты на это число и получается новая точка
https://docs.python.org/3/reference/datamodel.html

# 3 Большая задача про колоду карт

## 3.1 Игральная карта

Сделать класс Card

а) сделать конструктор - число либо буква J/Q/K/A + название масти

``` python
c1 = Card(5, 'spades')
c2 = Card('A', 'hearts')
```

* старшинство - число от 2 до 10, либо 'J', 'Q', 'K', 'A'
* масть - название масти строкой

Символ |  Код
------:|--------
   ♠   |'/u2660'
   ♣   |'/u2663'
   ♥   |'/u2665'
   ♦   |'/u2666'

б) сделать repr

* с1 -> '5♠'
* c2 -> 'A♥'

в) операции сравнения карт, правила будут такие
у мастей есть старшинство 
♠<♣<♦<♥
если у карт разные масти, то сравниваются на основе мастей
если масти одинаковые, то смотрим на старшинство, туз самый старший, 2 самая младшая


<details><summary>В помошь</summary>

``` python

valid_values = {2, 3, 4, 5, 6, 7, 8, 9, 10, 'J', 'Q', 'K', 'A'}

weights = {
    2: 101,
    3: 102,
    4: 103,
    5: 104,
    6: 105,
    7: 106,
    8: 107,
    9: 108,
    10: 109,
    'J': 110,
    'Q': 111,
    'K': 112,
    'A': 113
    }

valid_values = {'hearts', 'spades', 'clubs', 'diamonds'}

weights = { # ♠<♦<♣<♥
    'hearts': 1,
    'clubs': 2,
    'diamonds': 3,
    'spades': 4,
}

symbols = {
    'hearts': '\u2665',
    'clubs': '\u2663',
    'diamonds': '\u2666',
    'spades': '\u2660',
}

```

</details>